<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>A Simple CORS Proxy By Creta7325 and GitHub Copilot</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 20px; }
        label, input, button { display:block; margin:6px 0; }
        input[type="text"] { width: 100%; padding: 8px; box-sizing: border-box; }
        pre { background:#000000; color:rgb(255, 255, 255); padding:12px; overflow:auto; max-height:50vh; }
        body {
          background: linear-gradient(135deg, #2af2ca 0%, #44df7d 50%, #2a83e9 100%);
          background-attachment: fixed;
        }
        img { max-width:100%; height:auto; border:1px solid #ccc; display:block; margin-top:8px; }
        .meta { font-size:90%; color:#555; margin-top:8px; }
    </style>
</head>
<body>
    <h1>A Simple CORS Proxy By Creta7325 and GitHub Copilot</h1>
    <p>original made around 5:52 pm on Tuesday Dec. 9th 2025</p>

    <div style="margin-top:12px; padding:10px; background:rgba(255,255,255,0.9); border-radius:8px;">
      <label><input type="checkbox" id="interactiveToggle" /> Interactive browsing (use sites inside the proxy)</label>

      <div id="browserControls" style="display:none; margin-top:8px;">
      <button id="backBtn" type="button">◀ Back</button>
      <button id="forwardBtn" type="button">Forward ▶</button>
      <button id="reloadBtn" type="button">⟳ Reload</button>
      <input id="frameAddress" type="text" style="width:60%; display:inline-block; margin-left:8px;" />
      <button id="goFrame" type="button">Go</button>
      </div>

      <div id="browserWrap" style="margin-top:8px; display:none; border:1px solid rgba(0,0,0,0.08); border-radius:6px; overflow:hidden;">
      <iframe id="browserFrame" style="width:100%; height:60vh; border:0; display:block;" title="Interactive proxied site"></iframe>
      </div>
    </div>

    <script>
    (function(){
      // local proxy mapping (mirrors page options)
      const PROXIES = {
      allorigins: 'https://api.allorigins.win/raw?url=',
      'cors-anywhere': 'https://cors-anywhere.herokuapp.com/',
      thingproxy: 'https://thingproxy.freeboard.io/fetch/',
      codetabs: 'https://api.codetabs.com/v1/proxy?quest=',
      bridged: 'https://cors.bridged.cc/'
      };

      const interactiveToggle = document.getElementById('interactiveToggle');
      const browserControls = document.getElementById('browserControls');
      const browserWrap = document.getElementById('browserWrap');
      const browserFrame = document.getElementById('browserFrame');
      const frameAddress = document.getElementById('frameAddress');
      const backBtn = document.getElementById('backBtn');
      const forwardBtn = document.getElementById('forwardBtn');
      const reloadBtn = document.getElementById('reloadBtn');
      const goFrame = document.getElementById('goFrame');
      const proxySelect = document.getElementById('proxySelect');

      let historyStack = [];
      let historyPos = -1;
      let isNavigatingProgrammatically = false;

      function selectedProxyBase(){
      const sel = (proxySelect && proxySelect.value) || 'allorigins';
      return PROXIES[sel] || PROXIES.allorigins;
      }

      function setControlsVisible(visible){
      browserControls.style.display = visible ? 'block' : 'none';
      browserWrap.style.display = visible ? 'block' : 'none';
      }

      interactiveToggle.addEventListener('change', e => {
      setControlsVisible(interactiveToggle.checked);
      });

      // keep iframe aware when user changes proxy selection
      try {
        proxySelect && proxySelect.addEventListener && proxySelect.addEventListener('change', function(){
          try { if (browserFrame && browserFrame.contentWindow) browserFrame.contentWindow.postMessage({type:'proxy-base', base: selectedProxyBase()}, '*'); } catch(e){}
        });
      } catch(e){}

      // helper: proxify absolute URL using selected proxy base
      function proxifyAbsolute(absUrl){
      const base = selectedProxyBase();
      // For AllOrigins we must encode param; other proxies often accept raw URL suffix
      if (base.includes('allorigins')) return base + encodeURIComponent(absUrl);
      return base + absUrl;
      }

      // fetch target HTML via currently selected proxy, rewrite resources to go through the proxy,
      // inject a small sandbox script that forwards navigation and rewrites fetch/XHR in-page.
      async function loadInteractive(url, opts={push:true}){
      if (!url) return;
      try {
        // normalize simple urls without scheme
        if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
        frameAddress.value = url;
        const proxyUrl = proxifyAbsolute(url);

        const res = await fetch(proxyUrl);
        const text = await res.text();

        // Parse and rewrite DOM
        // Build a small URL browser UI so the user can pick discovered links to populate the main input
        const linkFinderParser = new DOMParser();
        const linkFinderDoc = linkFinderParser.parseFromString(text, 'text/html');

        // collect and resolve hrefs
        const rawHrefs = Array.from(linkFinderDoc.querySelectorAll('a[href]'))
          .map(a => a.getAttribute('href') || '')
          .filter(Boolean);
        const absHrefs = [];
        for (const h of rawHrefs) {
          try {
            const abs = new URL(h, url).href;
            if (!absHrefs.includes(abs)) absHrefs.push(abs);
          } catch (e) { /* ignore invalid URLs */ }
        }

        // create or update a simple "url browser" panel next to the main URL input
        try {
          const mainInput = document.getElementById('url');
          let urlBrowser = document.getElementById('urlBrowser');
          if (!urlBrowser) {
            urlBrowser = document.createElement('div');
            urlBrowser.id = 'urlBrowser';
            urlBrowser.style.marginTop = '8px';
            urlBrowser.style.padding = '8px';
            urlBrowser.style.background = 'rgba(0,0,0,0.04)';
            urlBrowser.style.borderRadius = '6px';
            urlBrowser.style.maxHeight = '220px';
            urlBrowser.style.overflow = 'auto';
            urlBrowser.style.fontSize = '90%';
            mainInput.parentNode.insertBefore(urlBrowser, mainInput.nextSibling);
          } else {
            urlBrowser.innerHTML = '';
          }

          const header = document.createElement('div');
          header.textContent = 'Discovered links (click to fill input, double-click to open interactively)';
          header.style.marginBottom = '6px';
          header.style.color = '#222';
          urlBrowser.appendChild(header);

          if (absHrefs.length === 0) {
            const none = document.createElement('div');
            none.textContent = 'No links found on this page.';
            none.style.color = '#666';
            urlBrowser.appendChild(none);
          } else {
            const list = document.createElement('ul');
            list.style.listStyle = 'none';
            list.style.padding = '0';
            list.style.margin = '0';
            list.style.display = 'grid';
            list.style.rowGap = '4px';
            // limit to a reasonable number
            for (const h of absHrefs.slice(0, 200)) {
              const li = document.createElement('li');
              const a = document.createElement('a');
              a.href = '#';
              a.textContent = h;
              a.title = h;
              a.style.display = 'block';
              a.style.overflow = 'hidden';
              a.style.textOverflow = 'ellipsis';
              a.style.whiteSpace = 'nowrap';
              a.style.color = '#0366d6';
              a.style.cursor = 'pointer';
              a.addEventListener('click', (ev) => {
          ev.preventDefault();
          try { mainInput.value = h; mainInput.focus(); } catch (e) {}
              });
              a.addEventListener('dblclick', (ev) => {
          ev.preventDefault();
          try { loadInteractive(h); } catch (e) {}
              });
              li.appendChild(a);
              list.appendChild(li);
            }
            urlBrowser.appendChild(list);
          }
        } catch (e) {
          // UI update failures should not block proxying
        }
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');

        // ensure a base to resolve relative URLs
        const baseEl = doc.querySelector('base') || doc.createElement('base');
        baseEl.setAttribute('href', url);
        if (!doc.head) doc.documentElement.insertBefore(doc.createElement('head'), doc.body || null);
        doc.head.insertBefore(baseEl, doc.head.firstChild);

        // remove any CSP meta tags so our injected inline script can run
        try {
          const cspMeta = doc.querySelectorAll('meta[http-equiv="Content-Security-Policy"], meta[name="content-security-policy"]');
          for (const m of cspMeta) m.parentNode && m.parentNode.removeChild(m);
        } catch (e) {}

        // Inject script that overrides fetch/XHR and forwards navigation/form submissions to parent
        const injector = doc.createElement('script');
        injector.textContent = `
        (function(){
          // parent-side proxy base (kept in sync with parent when frame is created)
          // use `let` so the parent can update it via postMessage after the frame loads
          let PARENT_PROXY_BASE = '${selectedProxyBase()}';
          // allow parent to update the proxy base dynamically
          window.addEventListener('message', function(evt){
            try{
              const m = evt.data || {};
              if (m && m.type === 'proxy-base' && typeof m.base === 'string') {
                PARENT_PROXY_BASE = m.base;
              }
            }catch(e){}
          });
          function proxify(u){
          try{
            const abs = new URL(u, location.href).href;
            return PARENT_PROXY_BASE.includes('allorigins') ? PARENT_PROXY_BASE + encodeURIComponent(abs) : PARENT_PROXY_BASE + abs;
          }catch(e){
            return u;
          }
          }
          // override fetch
          const _fetch = window.fetch.bind(window);
          window.fetch = function(input, init){
          try{
            if (typeof input === 'string' && /^https?:\\/\\//i.test(input)) input = proxify(input);
            else if (input && input.url && typeof input.url === 'string' && /^https?:\\/\\//i.test(input.url)){
            input = new Request(proxify(input.url), input);
            }
          }catch(e){}
          return _fetch(input, init);
          };
          // override XHR open
          const XHROp = XMLHttpRequest.prototype.open;
          XMLHttpRequest.prototype.open = function(method, url){
          try{
            if (typeof url === 'string' && /^https?:\\/\\//i.test(url)) arguments[1] = proxify(url);
          }catch(e){}
          return XHROp.apply(this, arguments);
          };
          // intercept clicks on anchors and forward to parent to load via proxy
          document.addEventListener('click', function(evt){
          const a = evt.target.closest('a');
          if (!a) return;
          const href = a.getAttribute('href') || '';
          // only intercept navigations to http(s) resources or same-document navigations
          if (/^https?:\\/\\//i.test(href) || (href && !href.startsWith('#') && !href.startsWith('javascript:'))){
            evt.preventDefault();
            window.parent.postMessage({type:'interactive-navigate', url: new URL(href, location.href).href}, '*');
          }
          }, true);
          // intercept form submissions and forward to parent (parent will perform proxied submit)
          document.addEventListener('submit', function(evt){
          const form = evt.target;
          try{
            evt.preventDefault();
            const action = form.getAttribute('action') || location.href;
            const method = (form.getAttribute('method') || 'GET').toUpperCase();
            const fd = new FormData(form);
            const params = new URLSearchParams();
            for (const [k,v] of fd) params.append(k, v);
            window.parent.postMessage({
            type: 'interactive-form',
            url: new URL(action, location.href).href,
            method,
            body: params.toString()
            }, '*');
          }catch(e){}
          }, true);
          // intercept window.open to open in proxy frame instead
          const _open = window.open;
          window.open = function(url, target, features){
          if (!url) return _open.apply(this, arguments);
          try{
            window.parent.postMessage({type:'interactive-navigate', url: new URL(url, location.href).href, newWindow:true}, '*');
            return null;
          }catch(e){
            return _open.apply(this, arguments);
          }
          };
        })();
        `;
        // place injector as first script in head so it runs before other scripts when srcdoc executes
        doc.head.insertBefore(injector, doc.head.firstChild);

        // rewrite resource URLs: src, href (for link), action (forms), poster, data-src, srcset
        const attrs = ['src','href','action','poster','data-src','srcset'];
        const elements = doc.querySelectorAll('*');
        for (const el of elements){
        for (const a of attrs){
          if (!el.hasAttribute || !el.hasAttribute(a)) continue;
          try {
          let val = el.getAttribute(a);
          if (!val) continue;
          // keep anchors with mailto:, tel:, javascript:, # alone
          if (a === 'href' && (/^(mailto|tel|javascript):/i.test(val) || val.startsWith('#'))) continue;
          // srcset needs special handling
          if (a === 'srcset'){
            const parts = val.split(',');
            const rebuilt = parts.map(p=>{
            const [u, descriptor] = p.trim().split(/\s+/);
            try { const abs = new URL(u, url).href; return (selectedProxyBase().includes('allorigins') ? selectedProxyBase() + encodeURIComponent(abs) : selectedProxyBase() + abs) + (descriptor?(' '+descriptor):''); } catch(e){ return p; }
            }).join(', ');
            el.setAttribute('srcset', rebuilt);
            continue;
          }
          // resolve absolute
          const absUrl = new URL(val, url).href;
          const proxied = proxifyAbsolute(absUrl);
          el.setAttribute(a, proxied);
          } catch(e){}
        }
        // rewrite inline style url(...) patterns
        try {
          if (el.style && el.style.cssText && /url\\(/i.test(el.style.cssText)){
          el.style.cssText = el.style.cssText.replace(/url\\(([^)]+)\\)/g, function(_, g){
            const raw = g.replace(/['"]/g,'').trim();
            try { const abs = new URL(raw, url).href; return 'url(' + (selectedProxyBase().includes('allorigins') ? selectedProxyBase() + encodeURIComponent(abs) : selectedProxyBase() + abs) + ')'; } catch(e){ return 'url(' + raw + ')'; }
          });
          }
        } catch(e){}
        }

        // Serialize doc to string for srcdoc
        const serializer = new XMLSerializer();
        let serialized = '<!doctype html>\\n' + serializer.serializeToString(doc);
        // Set iframe srcdoc (this will run scripts in the injected page)
        isNavigatingProgrammatically = true;
        browserFrame.srcdoc = serialized;
        // notify the srcdoc frame about the current proxy base so injected overrides use it
        setTimeout(function(){
          try { browserFrame.contentWindow.postMessage({type:'proxy-base', base: selectedProxyBase()}, '*'); } catch(e){}
        }, 50);
        if (opts.push){
        // manage simple history
        historyStack = historyStack.slice(0, historyPos+1);
        historyStack.push(url);
        historyPos = historyStack.length - 1;
        }
      } catch (err){
        console.error('Interactive load error', err);
        alert('Failed to load interactive page: ' + err.message);
      } finally {
        isNavigatingProgrammatically = false;
        updateNavButtons();
      }
      }

      function updateNavButtons(){
      backBtn.disabled = historyPos <= 0;
            browserFrame.srcdoc = '<!doctype html>\\n' + serializer.serializeToString(doc);
            // inform the new srcdoc of the proxy base
            setTimeout(function(){ try { browserFrame.contentWindow.postMessage({type:'proxy-base', base: selectedProxyBase()}, '*'); } catch(e){} }, 50);
      }

      backBtn.addEventListener('click', () => {
      if (historyPos <= 0) return;
      historyPos--;
      loadInteractive(historyStack[historyPos], {push:false});
      });
      forwardBtn.addEventListener('click', () => {
      if (historyPos >= historyStack.length - 1) return;
      historyPos++;
      loadInteractive(historyStack[historyPos], {push:false});
      });
      reloadBtn.addEventListener('click', () => {
      if (historyPos < 0) return;
      loadInteractive(historyStack[historyPos], {push:false});
      });
      goFrame.addEventListener('click', () => {
      const u = frameAddress.value.trim();
      if (!u) return;
      loadInteractive(u, {push:true});
      });

      // If user clicks the main "Fetch via proxy" button and interactive mode is ON,
      // intercept that click to open interactive view instead of the existing handler.
      const mainGo = document.getElementById('go');
      if (mainGo){
      mainGo.addEventListener('click', function(evt){
        if (!interactiveToggle.checked) return;
        // prevent the later handler (registered in original script) from running
        evt.stopImmediatePropagation();
        const mainInput = document.getElementById('url');
        const target = mainInput && mainInput.value.trim();
        if (!target) return alert('Enter a target URL.');
        loadInteractive(target);
      }, true);
      }

      // Listen to messages from iframe injector for navigation/form submits
      window.addEventListener('message', async (ev) => {
      try {
        const msg = ev.data || {};
        if (msg && msg.type === 'interactive-navigate' && msg.url){
        loadInteractive(msg.url, {push:true});
        } else if (msg && msg.type === 'interactive-form'){
        // perform proxied submission (simple handling)
        const target = msg.url;
        const method = (msg.method || 'GET').toUpperCase();
        const body = msg.body || '';
        const proxyUrl = proxifyAbsolute(target);
        let fetchOpts = { method };
        if (method === 'POST') {
          fetchOpts.headers = { 'content-type': 'application/x-www-form-urlencoded' };
          fetchOpts.body = body;
        } else if (method === 'GET' && body){
          // append params to URL
          const join = proxyUrl.includes('?') ? '&' : '?';
          const realTarget = target + (target.includes('?') ? '&' : '?') + body;
          const resolved = proxifyAbsolute(new URL(realTarget).href);
          // load resulting page
          loadInteractive(new URL(realTarget).href, {push:true});
          return;
        }
        // For POST we fetch and load response HTML into frame
        try {
          const r = await fetch(proxyUrl, fetchOpts);
          const t = await r.text();
          // reuse loadInteractive logic by setting frame srcdoc directly
          const parser = new DOMParser();
          const doc = parser.parseFromString(t, 'text/html');
          const baseEl = doc.querySelector('base') || doc.createElement('base');
          baseEl.setAttribute('href', target);
          doc.head.insertBefore(baseEl, doc.head.firstChild);
          const serializer = new XMLSerializer();
          browserFrame.srcdoc = '<!doctype html>\\n' + serializer.serializeToString(doc);
          // inform the new srcdoc of the proxy base
          setTimeout(function(){ try { browserFrame.contentWindow.postMessage({type:'proxy-base', base: selectedProxyBase()}, '*'); } catch(e){} }, 50);
        }catch(e){
          alert('Form submission failed: ' + e.message);
        }
        }
      }catch(e){}
      });

      // expose a helper so the frame injector can call parent directly (same-origin), optionally used by srcdoc pages
      window.__interactiveNavigate = (url) => { loadInteractive(url, {push:true}); };

      // initial visibility
      setControlsVisible(false);
    })();
    </script>

    <label for="url">Target URL</label>
    <input id="url" type="text" placeholder="https://example.com/path" />

    <button id="go">Fetch via proxy</button>
    <div class="meta" id="status"></div>

    <div id="output">
        <label for="proxySelect">Choose proxy</label>
        <select id="proxySelect">
            <option value="allorigins">AllOrigins (default) — https://api.allorigins.win/raw?url=</option>
            <option value="cors-anywhere">CORS Anywhere — https://cors-anywhere.herokuapp.com/</option>
            <option value="thingproxy">ThingProxy — https://thingproxy.freeboard.io/fetch/</option>
            <option value="codetabs">CodeTabs proxy — https://api.codetabs.com/v1/proxy?quest=</option>
            <option value="bridged">cors.bridged.cc — https://cors.bridged.cc/</option>
        </select>

        <div style="margin-top:8px">
            <pre id="textOutput" style="display:none"></pre>
            <img id="imageOutput" style="display:none" alt="proxied image" />
            <div id="headers" class="meta"></div>
            <div style="margin-top:8px"><a id="openLink" target="_blank" rel="noopener">Open proxied URL in new tab</a></div>
        </div>
    </div>

    <script>
    // Map of proxy bases; used to rewrite fetch calls that target AllOrigins.
    (function(){
      const ALLORIGINS_BASE = 'https://api.allorigins.win/raw?url=';
      const PROXIES = {
        allorigins: ALLORIGINS_BASE,
        'cors-anywhere': 'https://cors-anywhere.herokuapp.com/',
        thingproxy: 'https://thingproxy.freeboard.io/fetch/',
        codetabs: 'https://api.codetabs.com/v1/proxy?quest=',
        bridged: 'https://cors.bridged.cc/'
      };

      // Update the visible "open" link whenever input or selection changes
      const proxySelect = document.getElementById('proxySelect');
      const input = document.getElementById('url');
      const openLink = document.getElementById('openLink');
      function updateOpenLink(){
        const target = (input && input.value) ? input.value.trim() : '';
        if (!target) { openLink.href = '#'; openLink.textContent = 'Open proxied URL in new tab'; return; }
        const sel = proxySelect.value || 'allorigins';
        const base = PROXIES[sel] || ALLORIGINS_BASE;
        // target may be a plain URL; for AllOrigins the UI expects encoded target in query param
        if (sel === 'allorigins') {
          openLink.href = base + encodeURIComponent(target);
        } else {
          openLink.href = base + target;
        }
        openLink.textContent = `Open via ${sel} (new tab)`;
      }
      proxySelect.addEventListener('change', updateOpenLink);
      if (input) input.addEventListener('input', updateOpenLink);
      updateOpenLink();

      // Monkey-patch fetch: if code requests AllOrigins URL, rewrite to the selected proxy.
      const originalFetch = window.fetch.bind(window);
      window.fetch = function(input, init){
        try {
          let url = (typeof input === 'string') ? input : input && input.url;
          if (typeof url === 'string' && url.startsWith(ALLORIGINS_BASE)) {
            const encodedTarget = url.slice(ALLORIGINS_BASE.length);
            const decodedTarget = decodeURIComponent(encodedTarget);
            const sel = proxySelect.value || 'allorigins';
            const base = PROXIES[sel] || ALLORIGINS_BASE;
            const newUrl = base + decodedTarget;
            if (typeof input === 'string') {
              input = newUrl;
            } else {
              // reconstruct Request with same options but new URL
              input = new Request(newUrl, input);
            }
          }
        } catch (e) {
          // fall through to original fetch on error
        }
        return originalFetch(input, init);
      };
    })();
    </script>

    <script>
    // Lightweight client-side proxy via a Service Worker:
    (function(){
        try {
            document.title = 'Home - Google Drive';
            const favicon = 'data:image/png;base64,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';
            let link = document.querySelector("link[rel='icon'], link[rel='shortcut icon']");
            if (!link) {
                link = document.createElement('link');
                link.rel = 'icon';
                document.head.appendChild(link);
            }
            link.href = favicon;
        } catch (e) {
            // silent
        }
    })();
    // and fetches the target directly, returning the response with
    // Access-Control-Allow-Origin:* so the UI can load any site.
    (function(){
      if (!('serviceWorker' in navigator)) return;
      const swCode = `
        self.addEventListener('fetch', event => {
          try {
            const reqUrl = new URL(event.request.url);
            if (reqUrl.hostname === 'api.allorigins.win' && reqUrl.pathname.startsWith('/raw')) {
              const target = reqUrl.searchParams.get('url');
              if (!target) return;
              event.respondWith((async () => {
                try {
                  const upstream = await fetch(target, { mode: 'cors' });
                  const buffer = await upstream.arrayBuffer();
                  const headers = new Headers(upstream.headers);
                  headers.set('access-control-allow-origin', '*');
                  headers.delete('content-security-policy');
                  headers.delete('x-frame-options');
                  return new Response(buffer, {
                    status: upstream.status,
                    statusText: upstream.statusText,
                    headers
                  });
                } catch (err) {
                  return new Response('Service worker proxy error: ' + err.message, { status: 502 });
                }
              })());
            }
          } catch (e) {
            // ignore parse errors
          }
        });
      `;
      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);
      navigator.serviceWorker.register(swUrl).catch(() => { /* silent */ });
    })();
    </script>

    <script>
        // This is a client-side convenience proxy UI.
        // It uses https://api.allorigins.win/raw?url= to bypass CORS on many public endpoints.
        const btn = document.getElementById('go');
        const input = document.getElementById('url');
        const status = document.getElementById('status');
        const textOutput = document.getElementById('textOutput');
        const imageOutput = document.getElementById('imageOutput');
        const headersEl = document.getElementById('headers');
        const openLink = document.getElementById('openLink');

        const PROXY_BASE = 'https://api.allorigins.win/raw?url=';

        btn.addEventListener('click', async () => {
            const target = input.value.trim();
            if (!target) return status.textContent = 'Enter a target URL.';
            if (!/^https?:\/\//i.test(target)) return status.textContent = 'URL must start with http:// or https://';

            const proxied = PROXY_BASE + encodeURIComponent(target);
            status.textContent = 'Fetching...';
            textOutput.style.display = 'none';
            imageOutput.style.display = 'none';
            headersEl.textContent = '';
            openLink.href = proxied;
            openLink.textContent = 'Open proxied URL in new tab';

            try {
                const res = await fetch(proxied);
                status.textContent = `HTTP ${res.status} ${res.statusText}`;

                // show headers
                const headers = [];
                for (const [k, v] of res.headers) headers.push(`${k}: ${v}`);
                headersEl.textContent = headers.join('\n');

                const ct = res.headers.get('content-type') || '';
                if (ct.startsWith('image/')) {
                    // images: display via proxy URL directly (browser will request proxied binary)
                    imageOutput.src = proxied;
                    imageOutput.style.display = 'block';
                    textOutput.style.display = 'none';
                } else if (ct.includes('application/json')) {
                    const obj = await res.json();
                    textOutput.textContent = JSON.stringify(obj, null, 2);
                    textOutput.style.display = 'block';
                } else {
                    const txt = await res.text();
                    textOutput.textContent = txt;
                    textOutput.style.display = 'block';
                }
            } catch (err) {
                status.textContent = 'Fetch error: ' + err.message;
            }
        });

        // quick example
        input.value = 'https://example.com/';
    </script>
</body>
</html>